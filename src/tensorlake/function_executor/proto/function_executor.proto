syntax = "proto3";

package function_executor_service;

// The messages should not use any Python SDK objects. Only Function Executor implemented
// in Python is allowed to import Python SDK to run customer functions. This ensures that
// all the other components can be written in any language.

enum SerializedObjectEncoding {
    SERIALIZED_OBJECT_ENCODING_UNKNOWN = 0;
    SERIALIZED_OBJECT_ENCODING_UTF8_JSON = 1;
    SERIALIZED_OBJECT_ENCODING_UTF8_TEXT = 2;
    SERIALIZED_OBJECT_ENCODING_BINARY_PICKLE = 3;
    SERIALIZED_OBJECT_ENCODING_BINARY_ZIP = 4;
}

// Complete serialized object passed in a single message without any chunking.
message SerializedObject {
    optional bytes data = 1;
    optional SerializedObjectEncoding encoding = 2;
    optional uint64 encoding_version = 3;
}

/// Serializes the whole output object in a single binary blob.
// The size is the total size of the serialized object.
// Start offset is the offset of the output of a specific object if the function 
// output has multiple objects, for ex. List. 
// For the most common case, if the function output has a single object, the start_offset is 0.
message SerializedObjectUrl {
    optional string url = 1;
    optional uint64 size = 2;
    optional uint64 start_offset = 3;
    optional SerializedObjectEncoding encoding = 4;
    optional uint64 encoding_version = 5;
}

// InitializeRequest contains information about the function
// that Function Executor is going to run the tasks for.
message InitializeRequest {
    optional string namespace = 1;
    optional string graph_name = 2;
    optional string graph_version = 3;
    optional string function_name = 5;
    optional SerializedObject graph = 7;
}

enum InitializationOutcomeCode {
    INITIALIZE_OUTCOME_CODE_UNKNOWN = 0;
    INITIALIZE_OUTCOME_CODE_SUCCESS = 1;
    INITIALIZE_OUTCOME_CODE_FAILURE = 2;
}

enum InitializationFailureReason {
    INITIALIZATION_FAILURE_REASON_UNKNOWN = 0;
    INITIALIZATION_FAILURE_REASON_INTERNAL_ERROR = 1;
    INITIALIZATION_FAILURE_REASON_FUNCTION_ERROR = 2;
}

message InitializeResponse {
    optional InitializationOutcomeCode outcome_code = 1;
    optional InitializationFailureReason failure_reason = 2;
    optional string stdout = 3;
    optional string stderr = 4;
}

message SetInvocationStateRequest {
    optional string key = 1;
    optional SerializedObject value = 2;
}

message SetInvocationStateResponse {}

message GetInvocationStateRequest {
    optional string key = 1;
}

message GetInvocationStateResponse {
    optional string key = 1;
    optional SerializedObject value = 2;
}

// InvocationStateRequest is sent by RPC Server to the client
// to perform actions on a task's graph invocation state.
message InvocationStateRequest {
    // The ID of the request sent by the client.
    // Must be unique per Function Executor.
    optional string request_id = 1;
    // The ID of the task initiated the request.
    optional string task_id = 2;
    oneof request {
        SetInvocationStateRequest set = 3;
        GetInvocationStateRequest get = 4;
    }
}

// InvocationStateResponse is sent by RPC client to the Server.
// A response contains the result of the action performed on the
// task's graph invocation state.
message InvocationStateResponse {
    // The id of the request this response is for.
    optional string request_id = 1;
    optional bool success = 2;
    oneof response {
        SetInvocationStateResponse set = 3;
        GetInvocationStateResponse get = 4;
    }
}

message RunTaskRequest {
    optional string namespace = 1;
    optional string graph_name = 2;
    optional string graph_version = 3;
    optional string function_name = 4;
    optional string graph_invocation_id = 5;
    optional string task_id = 6;
    optional string allocation_id = 9;
    optional SerializedObject function_input = 7;
    optional SerializedObject function_init_value = 8;
}

message Metrics {
    map<string, float> timers = 1;
    map<string, uint64> counters = 2;
}

enum TaskOutcomeCode {
    TASK_OUTCOME_CODE_UNKNOWN = 0;
    TASK_OUTCOME_CODE_SUCCESS = 1;
    TASK_OUTCOME_CODE_FAILURE = 2;
}

enum TaskFailureReason {
    TASK_FAILURE_REASON_UNKNOWN = 0;
    TASK_FAILURE_REASON_INTERNAL_ERROR = 1;
    TASK_FAILURE_REASON_FUNCTION_ERROR = 2;
    TASK_FAILURE_REASON_INVOCATION_ERROR = 3;
}

message RunTaskResponse {
    optional string task_id = 1;
    repeated SerializedObject function_outputs = 2;
    // Edges that the function wants the invocation to be routed to.
    repeated string next_functions = 3;
    optional string stdout = 4;
    optional string stderr = 5;
    optional bool is_reducer = 6;
    optional Metrics metrics = 7;
    optional TaskOutcomeCode outcome_code = 8;
    optional TaskFailureReason failure_reason = 9;
    // User payload for invocation error if task failed with invocation error.
    optional SerializedObject invocation_error_output = 10;
}

message HealthCheckRequest {}

message HealthCheckResponse {
    optional bool healthy = 1;
    optional string status_message = 2;
}

message InfoRequest {}

message InfoResponse {
    // Internal version of this Function Executor.
    // Semantic versioning schema is used with format 0.0.0.
    // Used to support migrations.
    optional string version = 1;
    // The version of the SDK used in this Function Executor to run customer code.
    optional string sdk_version = 2;
    // The language of the SDK. Currently supported values:
    // - "python"
    optional string sdk_language = 3;
    // The version of the SDK language. The language's versioning format is used.
    optional string sdk_language_version = 4;
}

message RunTaskRequestFrame {
    optional string task_id = 1;
    optional SerializedObjectUrl input_url = 2;
    optional SerializedObjectUrl init_val_url = 3;
}

message BatchedRunTaskRequestFrame {
    repeated RunTaskRequestFrame requests = 1;
}

message RunTaskResponseFrame {
    optional string task_id = 1;
    optional SerializedObjectUrl output_url = 2;
    optional SerializedObjectUrl stdout_url = 3;
    optional SerializedObjectUrl stderr_url = 4;
    optional TaskOutcomeCode outcome_code = 5;
}

message HealthCheckRequestFrame {}

message HealthCheckResponseFrame {
    optional bool healthy = 1;
    optional string status_message = 2;
    repeated string running_tasks = 3;
}

message ProgressUpdate {
    optional uint64 total = 1;
    optional uint64 current = 2;
}

// The semantics of Executor <> FE processes remains the same. Executor forks a FE, and initializes it using the existing RPC API - initialize
// From there on the executor starts a stream with the FE for 1. Running tasks 2. Getting On-Demand Health Check results 3. Progress updates of tasks. 
// Not everything in this protocol has to be implemented at once. For example, we can keep using the existing Health Check RPCs for now.
// We also don't need to implement the progress update frames for now. 
// The MVP of this protocol to ship support for large files are the following frames:
// RunTaskRequestFrame, RunTaskResponseFrame, HealthCheckRequestFrame, HealthCheckResponseFrame, ProgressUpdate
//
// State Machine of the Protocol: 
// 1. Executor starts a bi-directional stream with the FE when it has to run tasks or get health check results if the FE is already initialized but idle.
// 2. Executor receives a request from Indexify server to run Task T1, T2, T3
// 3. Executor sends BatchedRunTaskRequestFrame with task_ids T1, T2, T3. The request has the URLs of the inputs and the init value
// 4. FE reads the blobs from the URLs and stores them in memory.
// We are not going to advertise any disk caching for large inputs right now. We will have to think about the semantics of streaming large inputs from 
// storage at a later point. We will likely have to introduce them using a Generator API. It's out of scope for now. 
// 5. After downloading the inputs, the FE starts running the tasks. 
// 6. As the tasks are running, if the user code wants to send progress updates, it will call and API on the context to send Progress Update. The FE 
// will translate this to a ProgressUpdate frame and send it to the executor. 
// 7. The FE requests the executor for a pre-signed URL to upload the outputs of the tasks.
// 8. The executor sends the pre-signed URL to the FE.
// 9. The FE uploads the outputs to the pre-signed URL.
// 10. Once the tasks are finished, the FE will send RunTaskResponseFrame for each task that has finished(successfully or not).
// 12. At that point the executor can consider the FE is done running everything.
// Note on resuming stream - 
// It is expected that a stream can break at any point. We don't want to lose valuable work done by the FE. 
// If the stream is resumed by reconnecting to the FE. the executor should first send a HealthCheckRequestFrame to the FE to check if the FE is healthy.
// If the FE is healthy, and it's running tasks, it should return the list of running tasks in the HealthCheckResponseFrame.
// At that point, the executor shouldn't send it more tasks to run, and simply continue waiting for task results
// or for progress updates, or for health check results. 
message FunctionExecutorIO {
    oneof frame {
        // Messages sent by Executor to FE to initiate running tasks.
        BatchedRunTaskRequestFrame task = 4;

        // Messages sent by FE to Executor to send task results.
        RunTaskResponseFrame response = 5;

        // Messages sent by Executor to FE to get health check results.
        HealthCheckRequestFrame health_check = 7;

        // Messages sent by FE to Executor to send health check results.
        HealthCheckResponseFrame health_check_response = 8;

        // Messages sent by FE to Executor to send progress updates.
        ProgressUpdate progress = 9;
    }
}

service FunctionExecutor {
    // Initializes the Function Executor to run tasks
    // for a particular function. This method is called only
    // once per Function Executor as it can only run a single function.
    // It should be called before calling RunTask for the function.
    rpc initialize(InitializeRequest) returns (InitializeResponse);
    // Initializes a server that sends requests to the client to perform actions on
    // a task's graph invocation state. This method is called only once per Function Executor
    // It should be called before calling RunTask for the function.
    rpc initialize_invocation_state_server(stream InvocationStateResponse) returns (stream InvocationStateRequest);
    // Executes the task defined in the request.
    // Multiple tasks can be running in parallel.
    rpc run_task(RunTaskRequest) returns (RunTaskResponse);
    // Health check method to check if the FE is able to run tasks.
    // The FE should be initialized before calling this method.
    rpc check_health(HealthCheckRequest) returns (HealthCheckResponse);
    // Information about this Function Executor.
    rpc get_info(InfoRequest) returns (InfoResponse);

    rpc run_task_stream(stream FunctionExecutorIO) returns (stream FunctionExecutorIO);
}
