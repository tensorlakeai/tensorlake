syntax = "proto3";

package function_executor_service;

// The messages should not use any Python SDK objects. Only Function Executor implemented
// in Python is allowed to import Python SDK to run customer functions. This ensures that
// all the other components can be written in any language.

enum SerializedObjectEncoding {
    SERIALIZED_OBJECT_ENCODING_UNKNOWN = 0;
    SERIALIZED_OBJECT_ENCODING_UTF8_JSON = 1;
    SERIALIZED_OBJECT_ENCODING_UTF8_TEXT = 2;
    SERIALIZED_OBJECT_ENCODING_BINARY_PICKLE = 3;
    SERIALIZED_OBJECT_ENCODING_BINARY_ZIP = 4;
}

// Complete serialized object passed in a single message without any chunking.
message SerializedObject {
    optional bytes data = 1;
    optional SerializedObjectEncoding encoding = 2;
    optional uint64 encoding_version = 3;
}

// InitializeRequest contains information about the function
// that Function Executor is going to run the tasks for.
message InitializeRequest {
    optional string namespace = 1;
    optional string graph_name = 2;
    optional string graph_version = 3;
    optional string function_name = 5;
    optional SerializedObject graph = 7;
}

enum InitializationOutcomeCode {
    INITIALIZE_OUTCOME_CODE_UNKNOWN = 0;
    INITIALIZE_OUTCOME_CODE_SUCCESS = 1;
    INITIALIZE_OUTCOME_CODE_FAILURE = 2;
}

enum InitializationFailureReason {
    INITIALIZATION_FAILURE_REASON_UNKNOWN = 0;
    INITIALIZATION_FAILURE_REASON_INTERNAL_ERROR = 1;
    INITIALIZATION_FAILURE_REASON_FUNCTION_ERROR = 2;
}

message InitializeResponse {
    optional InitializationOutcomeCode outcome_code = 1;
    optional InitializationFailureReason failure_reason = 2;
    optional string stdout = 3;
    optional string stderr = 4;
}

message SetInvocationStateRequest {
    optional string key = 1;
    optional SerializedObject value = 2;
}

message SetInvocationStateResponse {}

message GetInvocationStateRequest {
    optional string key = 1;
}

message GetInvocationStateResponse {
    optional string key = 1;
    optional SerializedObject value = 2;
}

// InvocationStateRequest is sent by RPC Server to the client
// to perform actions on a task's graph invocation state.
message InvocationStateRequest {
    // The ID of the request sent by the client.
    // Must be unique per Function Executor.
    optional string request_id = 1;
    // The ID of the task initiated the request.
    optional string task_id = 2;
    oneof request {
        SetInvocationStateRequest set = 3;
        GetInvocationStateRequest get = 4;
    }
}

// InvocationStateResponse is sent by RPC client to the Server.
// A response contains the result of the action performed on the
// task's graph invocation state.
message InvocationStateResponse {
    // The id of the request this response is for.
    optional string request_id = 1;
    optional bool success = 2;
    oneof response {
        SetInvocationStateResponse set = 3;
        GetInvocationStateResponse get = 4;
    }
}

message RunTaskRequest {
    optional string namespace = 1;
    optional string graph_name = 2;
    optional string graph_version = 3;
    optional string function_name = 4;
    optional string graph_invocation_id = 5;
    optional string task_id = 6;
    optional string allocation_id = 9;
    optional SerializedObject function_input = 7;
    optional SerializedObject function_init_value = 8;
}

message Metrics {
    map<string, float> timers = 1;
    map<string, uint64> counters = 2;
}

enum TaskOutcomeCode {
    TASK_OUTCOME_CODE_UNKNOWN = 0;
    TASK_OUTCOME_CODE_SUCCESS = 1;
    TASK_OUTCOME_CODE_FAILURE = 2;
}

enum TaskFailureReason {
    TASK_FAILURE_REASON_UNKNOWN = 0;
    TASK_FAILURE_REASON_INTERNAL_ERROR = 1;
    TASK_FAILURE_REASON_FUNCTION_ERROR = 2;
    TASK_FAILURE_REASON_INVOCATION_ERROR = 3;
}

message RunTaskResponse {
    optional string task_id = 1;
    repeated SerializedObject function_outputs = 2;
    // Edges that the function wants the invocation to be routed to.
    repeated string next_functions = 3;
    optional string stdout = 4;
    optional string stderr = 5;
    optional bool is_reducer = 6;
    optional Metrics metrics = 7;
    optional TaskOutcomeCode outcome_code = 8;
    optional TaskFailureReason failure_reason = 9;
    // User payload for invocation error if task failed with invocation error.
    optional SerializedObject invocation_error_output = 10;
}

message HealthCheckRequest {}

message HealthCheckResponse {
    optional bool healthy = 1;
    optional string status_message = 2;
}

message InfoRequest {}

message InfoResponse {
    // Internal version of this Function Executor.
    // Semantic versioning schema is used with format 0.0.0.
    // Used to support migrations.
    optional string version = 1;
    // The version of the SDK used in this Function Executor to run customer code.
    optional string sdk_version = 2;
    // The language of the SDK. Currently supported values:
    // - "python"
    optional string sdk_language = 3;
    // The version of the SDK language. The language's versioning format is used.
    optional string sdk_language_version = 4;
}

enum BlobType {
    BLOB_TYPE_UNKNOWN = 0;
    BLOB_TYPE_INPUT = 1;
    BLOB_TYPE_INIT = 2;
    BLOB_TYPE_OUTPUT = 3;
    BLOB_TYPE_STDOUT = 4;
    BLOB_TYPE_STDERR = 5;
}

message BlobTxInit {
    optional uint64 size = 1;
    optional string mime_type = 2;
    optional string task_id = 3;
    optional BlobType type = 4;
}

message BlobChunk {
    optional bytes data = 1;
}

message BlobTxFin {
    optional string checksum = 1;
}


message RunTaskRequestFrame {
    repeated string task_ids = 1;
}

message RunTaskResponseFrame {
    optional TaskOutcomeCode outcome_code = 1;
    optional TaskFailureReason failure_reason = 2;
    optional uint64 output_size = 3;
}

message RunTaskResponseFrameEnd {
}

message HealthCheckRequestFrame {}

message HealthCheckResponseFrame {
    optional bool healthy = 1;
    optional string status_message = 2;
    repeated string running_tasks = 3;
}

message ProgressUpdate {
    optional uint64 total = 1;
    optional uint64 current = 2;
}

// The semantics of Executor <> FE remains the same. Executor forks a FE, and initializes it using the existing RPC API - initialize
// From there on the executor starts a stream with the FE for 1. Running tasks 2. Getting On-Demand Health Check results 3. Progress updates of tasks. 
// Not everything in this protocol has to be implemented at once. For example, we can keep using the existing Health Check RPCs for now.
// We also don't need to implement the progress update frames for now. 
// The MVP of this protocol to ship support for large files are the following frames:
// BlobTxInit, BlobChunk, BlobTxFin, RunTaskRequestFrame, RunTaskResponseFrame, RunTaskResponseFrameEnd, HealthCheckRequestFrame, HealthCheckResponseFrame, ProgressUpdate
//
// State Machine of the Protocol: 
// 1. Executor starts a bi-directional stream with the FE when it has to run tasks or get health check results if the FE is already initialized but idle.
// 2. Executor receives a request from Indexify server to run Task T1, T2, T3
// 3. Executor sends RunTaskRequestFrame with task_ids T1, T2, T3
// 4. Executor sends BlobTxInit, BlobChunk, BlobTxFin for input payload of T1, T2, T3
// Note that each of these blob messages has to be sent in sequence. That is the frames for T1 has to be sent first, T2 next, and so on.enum
// At this point, the FE should buffer and store the input payloads for each task **In-Memory** of the container. 
// We are not going to advertise any disk caching for large inputs right now. We will have to think about the semantics of streaming large inputs from storag
// at a later point. We will likely have to introduce them using a Generator API. It's out of scope for now. 
// 5. After receiving the last BlobTxFin, the FE should start running the tasks. 
// 6. As the tasks are running, if the user code wants to send progress updates, it will call and API on the context to send Progress Update. THe FE 
// will translate this to a ProgressUpdate frame and send it to the executor. 
// 7. Once the tasks are finished, the FE will send RunTaskResponseFrame to initiate sending task results back to the executor.
// The RunTaskResponseFrame is the metadata of the output, and the outcome. For every task that has finished(successfully or not), the FE will send the following frames:
// RunTaskResponseFrame, BlobTxInit, [BlobChunk ..], BlobTxFin for the output payload of the task. 
// The Blob* Frames are optional and only sent if there are outputs, logs, etc. 
// After all the blobs of the tasks are sent the FE will send RunTaskResponseFrameEnd to indicate that all the tasks are finished.
// 8. At that point the executor can consider the FE is done running everything. 
// Note on resuming stream - 
// It is expected that a stream can break at any point. We don't want to lose valuable work done by the FE. 
// If the stream is resumed by reconnecting to the FE. the executor should first send a HealthCheckRequestFrame to the FE to check if the FE is healthy.
// If the FE is healthy, and it's running tasks, it should return the list of running tasks in the HealthCheckResponseFrame.
// At that point, the executor shouldn't send it more tasks to run, and simply continue waiting for task results
// or for progress updates, or for health check results. 
message FunctionExecutorIO {
    oneof frame {
        BlobTxInit init = 1;
        BlobChunk chunk = 2;
        BlobTxFin fin = 3;
        RunTaskRequestFrame task = 4;
        RunTaskResponseFrame response = 5;
        RunTaskResponseFrameEnd response_end = 6;
        HealthCheckRequestFrame health_check = 7;
        HealthCheckResponseFrame health_check_response = 8;
        ProgressUpdate progress = 9;
    }
}

service FunctionExecutor {
    // Initializes the Function Executor to run tasks
    // for a particular function. This method is called only
    // once per Function Executor as it can only run a single function.
    // It should be called before calling RunTask for the function.
    rpc initialize(InitializeRequest) returns (InitializeResponse);
    // Initializes a server that sends requests to the client to perform actions on
    // a task's graph invocation state. This method is called only once per Function Executor
    // It should be called before calling RunTask for the function.
    rpc initialize_invocation_state_server(stream InvocationStateResponse) returns (stream InvocationStateRequest);
    // Executes the task defined in the request.
    // Multiple tasks can be running in parallel.
    rpc run_task(RunTaskRequest) returns (RunTaskResponse);
    // Health check method to check if the FE is able to run tasks.
    // The FE should be initialized before calling this method.
    rpc check_health(HealthCheckRequest) returns (HealthCheckResponse);
    // Information about this Function Executor.
    rpc get_info(InfoRequest) returns (InfoResponse);

    rpc run_task_stream(stream FunctionExecutorIO) returns (stream FunctionExecutorIO);
}
