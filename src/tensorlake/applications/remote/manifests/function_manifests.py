from typing import (
    Any,
    Dict,
    List,
    Union,
)

from pydantic import BaseModel, ConfigDict, Field


class GPUResourceManifest(BaseModel):
    count: int
    model: str


class FunctionResourcesManifest(BaseModel):
    cpus: float
    memory_mb: int
    ephemeral_disk_mb: int
    gpus: List[GPUResourceManifest]


class JSONSchema(BaseModel):
    """
    A simplified JSON Schema model (Draft 2020-12 compliant).
    https://json-schema.org/draft/2020-12/json-schema-validation

    Used to define JSON schema for application function parameters and return values.
    The JSON schema is used for generating a JSON template for users and MCP clients
    to fill in when invoking application functions via HTTP.

    The model is a simplified version of the full JSON Schema specification because it
    contains only fields required for specifying JSON representation for basic Python
    types (with recursion). We also store schemas generated by Pydantic models in
    this format. Pydantic generates full JSON Schema with many more fields, but we only
    define fields that we render in curl commans and UI. The Pydantic-generated fields
    are still preserved in resulting JSON schema due to ConfigDict(extra='allow').
    """

    model_config = ConfigDict(extra="allow", populate_by_name=True)

    # This data structure is very sparse with most fields being optional.
    # This is why we use None default values everywhere.
    # Don't repeat this practice in other parts of the codebase,
    # it adds hard to understand expectations.
    # The default None values are not going to be serialized into JSON because
    # we use exclude_unset=True when serializing the model.

    # Basic Metadata
    title: str | None = None
    description: str | None = None
    # Default value for the field, if any.
    default: Any | None = None

    # Custom field for function parameters.
    # We use an alias "x-parameter-kind" so it appears nicely in the JSON output.
    parameter_kind: str | None = Field(None, alias="x-parameter-kind")

    # Basic types or a union of basic types
    type: str | List[str] | None = None
    # For union of complex types, see https://json-schema.org/draft/2020-12/json-schema-core#name-anyof
    anyOf: List["JSONSchema"] | None = None

    # For List/Tuple/Set
    items: Union["JSONSchema", bool, None] = None  # For homogenous lists/sets
    prefixItems: List["JSONSchema"] | None = None  # For tuples (positional)
    minItems: int | None = Field(None, ge=0)
    maxItems: int | None = Field(None, ge=0)
    uniqueItems: bool | None = None

    # For objects, pydantic models and named dicts
    properties: Dict[str, "JSONSchema"] | None = None
    # For dicts with arbitrary keys/values
    additionalProperties: Union["JSONSchema", bool, None] = None
    # For dict keys
    propertyNames: Union["JSONSchema", None] = None
    # Object property names that are required, used for pydantic models and named dicts
    required: List[str] | None = None
    # Reference to a definition (e.g., "#/$defs/MyUser")
    # We use 'ref' in Python, but it serializes to '$ref' in JSON.
    ref: str | None = Field(None, alias="$ref")
    # Dictionary of reusable schemas.
    # We use 'defs' in Python, but it serializes to '$defs' in JSON.
    defs: Dict[str, "JSONSchema"] | None = Field(None, alias="$defs")


# Rebuild model to update ForwardRefs for recursive fields
JSONSchema.model_rebuild()


class ParameterManifest(BaseModel):
    # Parameter name as defined in the function signature.
    name: str
    # JSON Schema object for the parameter type.
    data_type: JSONSchema
    # Parameter description from the function docstring, if available.
    description: str | None
    # True if the parameter has no default value in the JSONSchema (function signature).
    required: bool


class RetryPolicyManifest(BaseModel):
    max_retries: int
    initial_delay_sec: float
    max_delay_sec: float
    delay_multiplier: float


class PlacementConstraintsManifest(BaseModel):
    filter_expressions: List[str]
